<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>draw_m3_like_one_of_your_ZnJlbmNoIGdpcmxz</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background-color: black;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    .ascii-container {
      display: flex;
      flex-direction: column;
      font-family: monospace;
      font-size: 8px; /* Initial size, will be overridden by JS */
      line-height: 1;
      letter-spacing: 0px;
      white-space: pre;
      contain: layout style paint;
    }

    .ascii-line {
      color: white;
      opacity: 0.15;
      /* Removed transition for performance - updates are fast enough */
      will-change: opacity;
      contain: layout style;
    }

    .loading {
      color: white;
      font-family: monospace;
      opacity: 0.5;
    }

    .error {
      color: red;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <div class="ascii-container" id="container">
    <div class="loading">loading...</div>
  </div>

  <script>
    // Config
    const DEFAULT_FONT_SIZE = 10; // Default font size in pixels
    const MIN_FONT_SIZE = 4; // Minimum font size
    const CHAR_WIDTH_RATIO = 0.455; // Matches ascii_magic's width_ratio of 2.2

    const container = document.getElementById('container');
    let lines = [];
    let currentImage = null;
    let maxConstraints = null; // Will be set by orchestrator init message
    let currentFontSize = DEFAULT_FONT_SIZE;

    // GIF animation state
    let isAnimated = false;
    let frames = [];
    let currentFrameIndex = 0;

    // Load gallery and store selected image (don't render yet)
    async function loadGallery() {
      try {
        const response = await fetch('gallery.json');
        if (!response.ok) throw new Error('gallery.json not found');

        const gallery = await response.json();
        if (!gallery.images || gallery.images.length === 0) {
          throw new Error('no images in gallery');
        }

        // Check for URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const imageId = urlParams.get('image');

        if (imageId) {
          // Find specific image by ID
          currentImage = gallery.images.find(img => img.id === imageId);
          if (!currentImage) {
            console.warn(`Image '${imageId}' not found, selecting random`);
            currentImage = gallery.images[Math.floor(Math.random() * gallery.images.length)];
          }
        } else {
          // Pick a random image from the gallery
          currentImage = gallery.images[Math.floor(Math.random() * gallery.images.length)];
        }

        return currentImage;
      } catch (err) {
        container.innerHTML = `<div class="error">failed to load: ${err.message}</div>`;
        console.error('Failed to load ASCII art:', err);
        return null;
      }
    }

    // Calculate optimal font size to fit within constraints
    function calculateFontSize(columns, numLines, maxWidth, maxHeight) {
      // Calculate max font size that fits width
      const fontSizeByWidth = maxWidth / (columns * CHAR_WIDTH_RATIO);
      // Calculate max font size that fits height
      const fontSizeByHeight = maxHeight / numLines;
      // Use the smaller of the two, clamped between min and default (never scale UP)
      return Math.max(MIN_FONT_SIZE, Math.min(DEFAULT_FONT_SIZE, Math.floor(Math.min(fontSizeByWidth, fontSizeByHeight))));
    }

    // Render with current image and constraints
    function renderWithConstraints() {
      if (!currentImage) return;

      // Check if this is an animated GIF (has frames) or static image (has lines)
      isAnimated = Array.isArray(currentImage.frames) && currentImage.frames.length > 0;
      frames = isAnimated ? currentImage.frames : [currentImage.lines];
      currentFrameIndex = 0;

      const columns = currentImage.columns;
      const numLines = frames[0].length;

      if (maxConstraints) {
        // Calculate font size to fit within orchestrator constraints
        currentFontSize = calculateFontSize(columns, numLines, maxConstraints.maxWidth, maxConstraints.maxHeight);
      } else {
        // Standalone mode: use window dimensions or default
        const maxWidth = window.innerWidth - 20;
        const maxHeight = window.innerHeight - 20;
        currentFontSize = calculateFontSize(columns, numLines, maxWidth, maxHeight);
      }

      renderAscii(frames[0]);
      requestResize(columns, numLines);
    }

    // Advance to next frame (for animated GIFs)
    function nextFrame() {
      if (!isAnimated || frames.length <= 1) return;

      currentFrameIndex = (currentFrameIndex + 1) % frames.length;
      renderAscii(frames[currentFrameIndex]);
    }

    // Request parent window to resize based on ASCII dimensions
    function requestResize(columns, numLines) {
      const width = Math.ceil(columns * CHAR_WIDTH_RATIO * currentFontSize);
      const height = numLines * currentFontSize;

      // Send resize request to parent (orchestrator)
      if (window.parent !== window) {
        window.parent.postMessage({ type: 'resize', width, height }, '*');
      }
    }

    // Cache for opacity values to avoid unnecessary style updates
    let cachedOpacities = [];
    const OPACITY_THRESHOLD = 0.02; // Only update if opacity changed by more than this

    // Render ASCII art as individual lines (reuses existing elements when possible)
    function renderAscii(asciiLines) {
      const numLines = asciiLines.length;

      // Reuse existing line elements if count matches
      if (lines.length === numLines) {
        for (let i = 0; i < numLines; i++) {
          lines[i].textContent = asciiLines[i];
        }
      } else {
        // Need to recreate - different line count
        container.innerHTML = '';
        lines = [];
        cachedOpacities = [];

        for (let i = 0; i < numLines; i++) {
          const lineEl = document.createElement('div');
          lineEl.className = 'ascii-line';
          lineEl.textContent = asciiLines[i];
          container.appendChild(lineEl);
          lines.push(lineEl);
          cachedOpacities.push(0.15);
        }
      }

      container.style.fontSize = `${currentFontSize}px`;
    }

    // Pre-calculated constants for opacity mapping
    const MIN_OPACITY = 0.15;
    const OPACITY_RANGE = 0.85; // 1.0 - 0.15
    const INV_128 = 1 / 128;

    // Update line opacities based on time domain audio data
    function updateOpacities(timeDomainData) {
      const numLines = lines.length;
      if (numLines === 0) return;

      // timeDomainData is already array-like, no need to create new Uint8Array
      const dataLen = timeDomainData.length;
      const step = (dataLen / numLines) | 0; // Bitwise floor

      for (let i = 0; i < numLines; i++) {
        // Get sample value (0-255, center is 128)
        const sample = timeDomainData[i * step] || 128;

        // Calculate deviation from center and map to opacity
        // Optimized: combine operations, avoid abs() call
        let deviation = sample - 128;
        if (deviation < 0) deviation = -deviation;

        // Map deviation to opacity (0.15 to 1.0)
        const opacity = MIN_OPACITY + (deviation * INV_128 * OPACITY_RANGE);

        // Only update DOM if opacity changed significantly
        const cachedOpacity = cachedOpacities[i];
        if (cachedOpacity === undefined ||
            opacity - cachedOpacity > OPACITY_THRESHOLD ||
            cachedOpacity - opacity > OPACITY_THRESHOLD) {
          lines[i].style.opacity = opacity;
          cachedOpacities[i] = opacity;
        }
      }
    }

    // Listen for messages from orchestrator
    window.addEventListener('message', (e) => {
      if (!e.data) return;

      if (e.data.type === 'init') {
        // Received constraints from orchestrator
        maxConstraints = { maxWidth: e.data.maxWidth, maxHeight: e.data.maxHeight };
        receivingOrchestratorAudio = true;
        if (currentImage) {
          renderWithConstraints();
        }
      } else if (e.data.type === 'audio') {
        receivingOrchestratorAudio = true;
        if (e.data.timeDomainData) {
          updateOpacities(e.data.timeDomainData);
        }
        // Advance frame on beat (for animated GIFs)
        if (e.data.beat && isAnimated) {
          nextFrame();
        }
      }
    });

    // Standalone mode: initialize local audio
    let localAudioInitialized = false;
    let receivingOrchestratorAudio = false;

    async function initLocalAudio() {
      if (localAudioInitialized || receivingOrchestratorAudio) return;

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        const analyser = audioContext.createAnalyser();

        analyser.fftSize = 512;
        source.connect(analyser);

        const dataArray = new Uint8Array(analyser.fftSize);
        let lastUpdateTime = 0;
        const UPDATE_INTERVAL = 33; // ~30fps, match orchestrator

        function update(timestamp) {
          // Throttle to 30fps to match orchestrator
          if (timestamp - lastUpdateTime >= UPDATE_INTERVAL) {
            analyser.getByteTimeDomainData(dataArray);
            updateOpacities(dataArray);
            lastUpdateTime = timestamp;
          }
          requestAnimationFrame(update);
        }

        localAudioInitialized = true;
        requestAnimationFrame(update);
      } catch (err) {
        console.log('Microphone access denied - waiting for orchestrator audio');
      }
    }

    // Initialize: load gallery, then wait for orchestrator or render standalone
    async function init() {
      await loadGallery();

      // If in orchestrator, wait for init message (handled by message listener)
      // If standalone, render after a short delay
      if (window.parent === window) {
        // Standalone mode - render immediately
        renderWithConstraints();
      } else {
        // In iframe - wait a bit for init message, fallback to standalone render
        setTimeout(() => {
          if (lines.length === 0 && currentImage) {
            // No init received, render with defaults
            renderWithConstraints();
          }
        }, 500);
      }
    }

    init();

    // Only init local audio if not receiving external audio after a delay
    setTimeout(() => {
      if (lines.length > 0) {
        initLocalAudio();
      }
    }, 2000);
  </script>
</body>
</html>
