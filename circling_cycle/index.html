<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Animated Text Path</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: black;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    #svg-path {
      position: absolute;
      visibility: hidden;
    }
  </style>
</head>
<body>
  <!-- Hidden SVG used to define and measure the path -->
  <svg id="svg-path" xmlns="http://www.w3.org/2000/svg">
    <path id="text-path" d="M 0,-100 C 55,-100 100,-55 100,0 C 100,55 55,100 0,100 C -55,100 -100,55 -100,0 C -100,-55 -55,-100 0,-100" />
  </svg>

  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const pathElement = document.getElementById('text-path');

    // Configuration
    const config = {
      targetWord: 'love',
      fontSize: 32,
      fontFamily: 'monospace',
      defaultOpacity: 0.5,
      highlightOpacity: 1.0,
      pathSpeed: 0.000075,      // Speed of characters moving along path
    };

    // Audio-reactive speed settings (time-domain volume typically 0-30)
    const MIN_HIGHLIGHT_SPEED = config.pathSpeed * 1.2;  // 20% faster than path in silence
    const MAX_HIGHLIGHT_SPEED = 0.0004;                   // ~5x pathSpeed when loud
    const VOLUME_SCALE = 15;                              // Sensitivity (lower = more sensitive)
    const SPEED_UPDATE_INTERVAL = 100;                    // ms between speed updates

    // Audio settings (standardized)
    const FFT_SIZE = 512;

    // ==========================================================================
    // EXTERNAL AUDIO (from orchestrator)
    // ==========================================================================

    let externalAudio = null;

    window.addEventListener('message', (e) => {
      if (e.data && e.data.type === 'audio') {
        externalAudio = e.data;
        document.body.style.backgroundColor = 'black';
      }
    });

    // ==========================================================================
    // LOCAL AUDIO (standalone mode)
    // ==========================================================================

    let audioContext = null;
    let analyser = null;
    let timeDomainData = null;
    let currentHighlightSpeed = MIN_HIGHLIGHT_SPEED;
    let lastSpeedUpdate = 0;
    let mediaStream = null;

    // Gallery data (loaded from gallery.json)
    let gallery = null;
    let shapes = [];
    let words = [];

    // Get URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const shapeParam = urlParams.get('shape'); // specific shape ID or null for random

    // State
    let pathOffset = 0;
    let highlightOffset = 0;
    let lastTime = 0;
    let pathLength = 0;
    let scale = 1;

    // Path cache for performance (avoid getPointAtLength every frame)
    const PATH_CACHE_RESOLUTION = 360; // Sample points around the path
    let pathCache = []; // [{x, y, angle}, ...]

    // Text cache (avoid recalculating every frame)
    let cachedCharCount = 0;
    let cachedPathText = '';

    // Build path cache - call once at setup and on shape change
    function buildPathCache() {
      pathCache = [];
      for (let i = 0; i < PATH_CACHE_RESOLUTION; i++) {
        const t = i / PATH_CACHE_RESOLUTION;
        const distance = t * pathLength;
        const point = pathElement.getPointAtLength(distance);

        // Get next point for angle calculation
        const nextDistance = ((i + 1) % PATH_CACHE_RESOLUTION) / PATH_CACHE_RESOLUTION * pathLength;
        const nextPoint = pathElement.getPointAtLength(nextDistance);
        const angle = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x);

        pathCache.push({ x: point.x, y: point.y, angle });
      }
    }

    // Load shapes from JSON
    async function loadGallery() {
      try {
        const response = await fetch('shapes.json');
        if (!response.ok) throw new Error('shapes.json not found');

        gallery = await response.json();
        shapes = gallery.shapes;
        words = gallery.words;
        return true;
      } catch (err) {
        console.error('Failed to load shapes:', err);
        return false;
      }
    }

    // Select shape and word (called once at startup after gallery is loaded)
    function selectShapeAndWord() {
      if (!gallery || shapes.length === 0 || words.length === 0) {
        console.error('Gallery not loaded');
        return;
      }

      // Select shape (specific or random)
      let selectedShape;
      if (shapeParam) {
        selectedShape = shapes.find(s => s.id === shapeParam);
        if (!selectedShape) {
          console.warn(`Shape '${shapeParam}' not found, selecting random`);
          selectedShape = shapes[Math.floor(Math.random() * shapes.length)];
        }
      } else {
        selectedShape = shapes[Math.floor(Math.random() * shapes.length)];
      }

      // Select random word
      const randomWord = words[Math.floor(Math.random() * words.length)];

      pathElement.setAttribute('d', selectedShape.path);
      config.targetWord = randomWord;
      pathLength = pathElement.getTotalLength();
      buildPathCache(); // Pre-compute path points
      updateTextCache(); // Update text after path is ready
    }

    // Initialize audio for reactive highlight speed
    async function initAudio() {
      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = FFT_SIZE;
        analyser.smoothingTimeConstant = 0.3;

        const source = audioContext.createMediaStreamSource(mediaStream);
        source.connect(analyser);

        timeDomainData = new Uint8Array(analyser.fftSize);
      } catch (err) {
        console.log('Microphone access denied - will use external audio if available');
        // Don't set red background - external audio may come in
      }
    }

    // Clean up audio stream on window close
    window.addEventListener('beforeunload', () => {
      if (mediaStream) {
        mediaStream.getTracks().forEach(track => track.stop());
      }
      if (audioContext) {
        audioContext.close();
      }
    });

    // Get local volume (standalone mode)
    function getLocalVolume() {
      if (!analyser) return 0;
      analyser.getByteTimeDomainData(timeDomainData);
      let sum = 0;
      for (let i = 0; i < timeDomainData.length; i++) {
        sum += Math.abs(timeDomainData[i] - 128);
      }
      return sum / timeDomainData.length;
    }

    // Calculate dynamic highlight speed based on normalized volume
    function getHighlightSpeed() {
      // Use pre-computed normalizedVolume from orchestrator
      if (externalAudio && externalAudio.normalizedVolume !== undefined) {
        return MIN_HIGHLIGHT_SPEED + externalAudio.normalizedVolume * (MAX_HIGHLIGHT_SPEED - MIN_HIGHLIGHT_SPEED);
      }
      // Fallback to local volume calculation
      const normalized = Math.min(getLocalVolume() / VOLUME_SCALE, 1);
      return MIN_HIGHLIGHT_SPEED + normalized * (MAX_HIGHLIGHT_SPEED - MIN_HIGHLIGHT_SPEED);
    }

    // Setup canvas and calculate scale
    function setupCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      // Scale based on the smaller dimension, targeting 80% of viewport
      const minDimension = Math.min(canvas.width, canvas.height);
      scale = (minDimension * 0.8) / 400; // 400 is the base path size
      updateTextCache();
    }

    // Update cached text values (call on resize or word change)
    function updateTextCache() {
      if (pathLength === 0) return; // Path not ready yet
      cachedCharCount = calculateCharacterCount();
      cachedPathText = generatePathText(cachedCharCount);
    }

    // Calculate how many characters fit on the path
    function calculateCharacterCount() {
      const charWidth = config.fontSize * 0.6; // Approximate monospace char width
      return Math.floor((pathLength * scale) / charWidth);
    }

    // Generate the repeated word string to fill the path
    function generatePathText(length) {
      const word = config.targetWord.toLowerCase().replace(/[^a-z]/g, '');
      let text = '';
      while (text.length < length) {
        text += word;
      }
      return text.substring(0, length);
    }

    // Get position and angle on SVG path at a given fraction (0 to 1)
    // Uses cached points with linear interpolation for performance
    function getPositionOnPath(t, centerX, centerY) {
      // Normalize t to [0, 1)
      t = t - Math.floor(t);

      // Find the two cached points to interpolate between
      const exactIndex = t * PATH_CACHE_RESOLUTION;
      const index0 = Math.floor(exactIndex) % PATH_CACHE_RESOLUTION;
      const index1 = (index0 + 1) % PATH_CACHE_RESOLUTION;
      const frac = exactIndex - Math.floor(exactIndex);

      const p0 = pathCache[index0];
      const p1 = pathCache[index1];

      // Linear interpolation
      const x = p0.x + (p1.x - p0.x) * frac;
      const y = p0.y + (p1.y - p0.y) * frac;

      return {
        x: centerX + x * scale,
        y: centerY + y * scale,
        angle: p0.angle, // Use nearest angle (good enough for text)
      };
    }

    // Check if character index is part of the highlighted word
    function isHighlighted(charIndex, totalChars, highlightPosition) {
      const wordLength = config.targetWord.length;
      const highlightStart = Math.floor(highlightPosition * totalChars) % totalChars;

      for (let i = 0; i < wordLength; i++) {
        const checkIndex = (highlightStart + i) % totalChars;
        if (checkIndex === charIndex) {
          return true;
        }
      }
      return false;
    }

    // Main render function
    function render(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;

      // Update highlight speed (throttled)
      if (timestamp - lastSpeedUpdate >= SPEED_UPDATE_INTERVAL) {
        lastSpeedUpdate = timestamp;
        currentHighlightSpeed = getHighlightSpeed();
      }

      // Update offsets
      pathOffset += config.pathSpeed * deltaTime;
      highlightOffset += currentHighlightSpeed * deltaTime;

      // Keep offsets in range [0, 1]
      pathOffset = pathOffset % 1;
      highlightOffset = highlightOffset % 1;

      // Clear canvas
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      // Set font
      ctx.font = `${config.fontSize}px ${config.fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Draw each character using cached values
      for (let i = 0; i < cachedCharCount; i++) {
        // Calculate position along path (0 to 1) with animation offset
        const baseT = i / cachedCharCount;
        const animatedT = (baseT + pathOffset) % 1;

        const pos = getPositionOnPath(animatedT, centerX, centerY);

        // Determine if this character is highlighted
        const highlighted = isHighlighted(i, cachedCharCount, highlightOffset);
        const opacity = highlighted ? config.highlightOpacity : config.defaultOpacity;

        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;

        // Draw character (always upright)
        ctx.fillText(cachedPathText[i], pos.x, pos.y);
      }

      requestAnimationFrame(render);
    }

    // Handle resize
    window.addEventListener('resize', setupCanvas);

    // Initialize
    async function init() {
      setupCanvas();
      await loadGallery();    // Load gallery first
      selectShapeAndWord();   // Pick shape and word from gallery
      initAudio();            // Initialize microphone for audio-reactive speed
      requestAnimationFrame(render);
    }

    init();
  </script>
</body>
</html>
