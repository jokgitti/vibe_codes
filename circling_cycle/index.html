<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Animated Text Path</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: black;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    #svg-path {
      position: absolute;
      visibility: hidden;
    }
  </style>
</head>
<body>
  <!-- Hidden SVG used to define and measure the path -->
  <svg id="svg-path" xmlns="http://www.w3.org/2000/svg">
    <path id="text-path" d="M 0,-100 C 55,-100 100,-55 100,0 C 100,55 55,100 0,100 C -55,100 -100,55 -100,0 C -100,-55 -55,-100 0,-100" />
  </svg>

  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const pathElement = document.getElementById('text-path');

    // Configuration
    const config = {
      targetWord: 'love',
      fontSize: 32,
      fontFamily: 'monospace',
      defaultOpacity: 0.5,
      highlightOpacity: 1.0,
      pathSpeed: 0.000075,      // Speed of characters moving along path
    };

    // Audio-reactive speed settings
    const MIN_HIGHLIGHT_SPEED = config.pathSpeed * 1.2;  // 20% faster than path in silence
    const MAX_HIGHLIGHT_SPEED = 0.0004;                   // ~5x pathSpeed when loud
    const VOLUME_SCALE = 24;                              // Sensitivity (lower = more sensitive)
    const SPEED_UPDATE_INTERVAL = 100;                    // ms between speed updates

    // Audio state
    let audioContext = null;
    let analyser = null;
    let timeDomainData = null;
    let currentVolume = 0;
    let currentHighlightSpeed = MIN_HIGHLIGHT_SPEED;
    let lastSpeedUpdate = 0;
    let mediaStream = null;  // Keep reference to stop on close

    // External audio (from orchestrator via postMessage)
    let externalAudio = null;

    // Listen for external audio data from orchestrator
    window.addEventListener('message', (e) => {
      if (e.data && e.data.type === 'audio') {
        externalAudio = e.data;
      }
    });

    // Word list (20 words, max 6 characters)
    const words = [
      'love', 'star', 'dream', 'hope', 'shine',
      'peace', 'happy', 'smile', 'dance', 'magic',
      'light', 'music', 'heart', 'sweet', 'brave',
      'free', 'wild', 'calm', 'joy', 'glow'
    ];

    // Example paths - change the 'd' attribute of #text-path to use different shapes
    const paths = {
      // Circle (radius 200)
      circle: 'M 0,-200 C 110,-200 200,-110 200,0 C 200,110 110,200 0,200 C -110,200 -200,110 -200,0 C -200,-110 -110,-200 0,-200',
      // S-shape
      sShape: 'M 0,-200 C 160,-200 160,0 0,0 C -160,0 -160,200 0,200',
      // Figure 8
      figure8: 'M 0,0 C 100,-100 200,-100 200,0 C 200,100 100,100 0,0 C -100,-100 -200,-100 -200,0 C -200,100 -100,100 0,0',
      // Heart
      heart: 'M 0,-130 C 60,-190 160,-130 160,-30 C 160,70 80,130 0,190 C -80,130 -160,70 -160,-30 C -160,-130 -60,-190 0,-130',
      // Star (5 points)
      star: 'M 0,-200 L 44,-70 L 190,-70 L 70,20 L 118,150 L 0,70 L -118,150 L -70,20 L -190,-70 L -44,-70 Z',
    };

    // Get array of path keys for random selection
    const pathKeys = Object.keys(paths);

    // Set initial path
    pathElement.setAttribute('d', paths.heart);

    // State
    let pathOffset = 0;
    let highlightOffset = 0;
    let lastTime = 0;
    let pathLength = 0;
    let scale = 1;

    // Randomly select shape and word (called once at startup)
    function selectShapeAndWord() {
      const randomPathKey = pathKeys[Math.floor(Math.random() * pathKeys.length)];
      const randomWord = words[Math.floor(Math.random() * words.length)];

      pathElement.setAttribute('d', paths[randomPathKey]);
      config.targetWord = randomWord;
      pathLength = pathElement.getTotalLength();
    }

    // Initialize audio for reactive highlight speed
    async function initAudio() {
      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;

        const source = audioContext.createMediaStreamSource(mediaStream);
        source.connect(analyser);

        timeDomainData = new Uint8Array(analyser.fftSize);
      } catch (err) {
        console.log('Microphone access denied - using static speed');
        document.body.style.backgroundColor = 'red';
      }
    }

    // Clean up audio stream on window close
    window.addEventListener('beforeunload', () => {
      if (mediaStream) {
        mediaStream.getTracks().forEach(track => track.stop());
      }
      if (audioContext) {
        audioContext.close();
      }
    });

    // Calculate volume from time-domain data
    function getVolume() {
      // Use external audio data if available (orchestrator mode)
      if (externalAudio && externalAudio.volume !== undefined) {
        return externalAudio.volume;
      }

      // Fallback to local audio (standalone mode)
      if (!analyser) return 0;

      analyser.getByteTimeDomainData(timeDomainData);
      let sum = 0;
      for (let i = 0; i < timeDomainData.length; i++) {
        const deviation = Math.abs(timeDomainData[i] - 128);
        sum += deviation;
      }
      return sum / timeDomainData.length;
    }

    // Calculate dynamic highlight speed based on volume
    function getHighlightSpeed() {
      const normalized = Math.min(currentVolume / VOLUME_SCALE, 1);
      return MIN_HIGHLIGHT_SPEED + normalized * (MAX_HIGHLIGHT_SPEED - MIN_HIGHLIGHT_SPEED);
    }

    // Setup canvas and calculate scale
    function setupCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      // Scale based on the smaller dimension, targeting 80% of viewport
      const minDimension = Math.min(canvas.width, canvas.height);
      scale = (minDimension * 0.8) / 400; // 400 is the base path size
    }

    // Calculate how many characters fit on the path
    function calculateCharacterCount() {
      const charWidth = config.fontSize * 0.6; // Approximate monospace char width
      return Math.floor((pathLength * scale) / charWidth);
    }

    // Generate the repeated word string to fill the path
    function generatePathText(length) {
      const word = config.targetWord.toLowerCase().replace(/[^a-z]/g, '');
      let text = '';
      while (text.length < length) {
        text += word;
      }
      return text.substring(0, length);
    }

    // Get position and angle on SVG path at a given fraction (0 to 1)
    function getPositionOnPath(t, centerX, centerY) {
      const distance = t * pathLength;
      const point = pathElement.getPointAtLength(distance);

      // Get a nearby point to calculate angle
      const delta = 0.1;
      const nextPoint = pathElement.getPointAtLength(Math.min(distance + delta, pathLength));
      const angle = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x);

      return {
        x: centerX + point.x * scale,
        y: centerY + point.y * scale,
        angle: angle,
      };
    }

    // Check if character index is part of the highlighted word
    function isHighlighted(charIndex, totalChars, highlightPosition) {
      const wordLength = config.targetWord.length;
      const highlightStart = Math.floor(highlightPosition * totalChars) % totalChars;

      for (let i = 0; i < wordLength; i++) {
        const checkIndex = (highlightStart + i) % totalChars;
        if (checkIndex === charIndex) {
          return true;
        }
      }
      return false;
    }

    // Main render function
    function render(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;

      // Update audio volume and highlight speed (throttled)
      currentVolume = getVolume();
      if (timestamp - lastSpeedUpdate >= SPEED_UPDATE_INTERVAL) {
        lastSpeedUpdate = timestamp;
        currentHighlightSpeed = getHighlightSpeed();
      }

      // Update offsets
      pathOffset += config.pathSpeed * deltaTime;
      highlightOffset += currentHighlightSpeed * deltaTime;

      // Keep offsets in range [0, 1]
      pathOffset = pathOffset % 1;
      highlightOffset = highlightOffset % 1;

      // Clear canvas
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const charCount = calculateCharacterCount();
      const pathText = generatePathText(charCount);

      // Set font
      ctx.font = `${config.fontSize}px ${config.fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Draw each character
      for (let i = 0; i < charCount; i++) {
        // Calculate position along path (0 to 1) with animation offset
        const baseT = i / charCount;
        const animatedT = (baseT + pathOffset) % 1;

        const pos = getPositionOnPath(animatedT, centerX, centerY);

        // Determine if this character is highlighted
        const highlighted = isHighlighted(i, charCount, highlightOffset);
        const opacity = highlighted ? config.highlightOpacity : config.defaultOpacity;

        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;

        // Draw character (always upright)
        ctx.fillText(pathText[i], pos.x, pos.y);
      }

      requestAnimationFrame(render);
    }

    // Handle resize
    window.addEventListener('resize', setupCanvas);

    // Initialize
    setupCanvas();
    selectShapeAndWord();  // Pick random shape and word once at startup
    initAudio();           // Initialize microphone for audio-reactive speed
    requestAnimationFrame(render);
  </script>
</body>
</html>
