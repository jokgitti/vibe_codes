<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rotating Wireframe</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        background: #000;
      }
      #canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #fff;
        font-family: monospace;
        font-size: 14px;
        text-align: center;
      }
      #error {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #ff4444;
        font-family: monospace;
        font-size: 12px;
        text-align: center;
        max-width: 80%;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div id="loading">Loading model...</div>
    <div id="error"></div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

      // State
      let scene, camera, renderer, model;

      // Config
      const ROTATION_SPEED = 0.01;

      // Initialize Three.js scene
      function initScene() {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // Camera
        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000,
        );
        camera.position.z = 5;

        // Renderer
        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById("canvas"),
          antialias: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // Lighting (even wireframes benefit from some ambient light)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // Handle window resize
        window.addEventListener("resize", onWindowResize);
      }

      // Load GLB model
      function loadModel() {
        const loader = new GLTFLoader();

        loader.load(
          "./model.glb",
          (gltf) => {
            model = gltf.scene;

            // Convert all meshes to wireframe
            model.traverse((child) => {
              if (child.isMesh) {
                child.material = new THREE.MeshBasicMaterial({
                  color: 0xffffff,
                  wireframe: true,
                  wireframeLinewidth: 1,
                });
              }
            });

            // Fix model orientation - rotate 90 degrees on X axis
            model.rotation.x = -Math.PI / 2;

            // Calculate visible height at camera distance
            const vFOV = (camera.fov * Math.PI) / 180;
            const visibleHeight = 2 * Math.tan(vFOV / 2) * camera.position.z;

            // Get bounding box after rotation
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            // Center on X and Z
            model.position.set(-center.x, -center.y, -center.z);

            // Scale to fill 80% of viewport height
            const targetHeight = visibleHeight * 0.8;
            const scaleFactor = targetHeight / size.y;
            model.scale.multiplyScalar(scaleFactor);

            // Position Y at -33% of viewport height
            model.position.y = -visibleHeight * 0.33;

            scene.add(model);

            document.getElementById("loading").style.display = "none";

            // Start animation loop
            animate();
          },
          (progress) => {
            const percent = Math.round(
              (progress.loaded / progress.total) * 100,
            );
            document.getElementById("loading").textContent =
              `Loading model... ${percent}%`;
          },
          (error) => {
            console.error("Error loading model:", error);
            document.getElementById("loading").style.display = "none";
            const errorEl = document.getElementById("error");
            errorEl.style.display = "block";
            errorEl.textContent =
              "Failed to load model.glb\nMake sure the file exists in the same folder";
          },
        );
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        if (model) {
          // Simple constant rotation (turntable)
          model.rotation.z += ROTATION_SPEED;
        }

        renderer.render(scene, camera);
      }

      // Handle window resize
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Initialize app
      function init() {
        initScene();
        loadModel();
      }

      // Start
      init();
    </script>
  </body>
</html>
